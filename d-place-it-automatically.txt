/**
 Maze Tracer (with D-button and URL prompt to download & center the ref image)
 Paste into Processing / APDE.
*/

import java.net.*;
import java.io.*;

// ==================== State ====================
ArrayList<PVector> points = new ArrayList<PVector>(); // rasterized grid path (world coords)
ArrayList<PVector> path = new ArrayList<PVector>();   // tracer tail (screen coords)
ArrayList<PVector> clicked = new ArrayList<PVector>(); // user-clicked points (world coords, snapped)

int currentSegment = 0;
float t = 0;
int duration = 6000; // full loop time (ms)
int lastMillis;
PVector originOffset; // world (0,0) -> screen center

// ====== Grid / hex (hex overlay optional) ======
boolean pointyTop = true; // for optional hex overlay
int gridStep = 20; // square grid spacing (pixels)

// ====== Visual toggles ======
boolean showCartesianGrid = true;
boolean showHexGrid = false;
float hexSize = 50;
int hexRadiusToDraw = 9;

// ====== Modes ======
final int MODE_POINT_ENTRY = 0;
final int MODE_LINES_BUILT = 1;
final int MODE_TRACING = 2;
int mode = MODE_POINT_ENTRY;

// ====== Buttons (simple) ======
class Btn {
  String label;
  float x, y, w, h;
  int id; // 0=POF, 1=LOF, 2=ST, 3=D
  Btn(String label, float x, float y, float w, float h, int id){
    this.label = label; this.x=x; this.y=y; this.w=w; this.h=h; this.id=id;
  }
  void draw(){
    boolean hov = over(mouseX, mouseY);
    stroke(0);
    strokeWeight(2);
    fill(hov ? 230 : 245);
    rect(x, y, w, h, 10);
    fill(0);
    textAlign(CENTER, CENTER);
    textSize(20);
    text(label, x + w/2, y + h/2);
  }
  boolean over(float mx, float my){ return mx>=x && mx<=x+w && my>=y && my<=y+h; }
  void click(){ if (!over(mouseX, mouseY)) return; if (id==0) onPOF(); else if (id==1) onLOF(); else if (id==2) onST(); else if (id==3) onD(); }
}
Btn btnPOF, btnLOF, btnST, btnD;

// ==================== Reference image overlay ====================
PImage refImg;
boolean showRef = true;
float refAlpha = 200; // 0..255
float refScale = 0.6; // initial scale
PVector refPos; // top-left screen position
boolean draggingRef = false;
PVector dragOffset;
String defaultImageUrl = "https://pressbooks.nvcc.edu/app/uploads/sites/55/2024/07/Fig-Step-3-1-1.jpg";
String imageUrl = defaultImageUrl;
String localImageName = "Figure-Step-3.jpg"; // will be saved to sketch/data/

boolean overRef(float mx, float my){
  if (!showRef || refImg == null) return false;
  float w = refImg.width * refScale;
  float h = refImg.height * refScale;
  return mx >= refPos.x && mx <= refPos.x + w && my >= refPos.y && my <= refPos.y + h;
}
void startDragRef(float mx, float my){
  draggingRef = true;
  dragOffset = new PVector(mx - refPos.x, my - refPos.y);
}
void endDragRef(){ draggingRef = false; }

// ==================== URL prompt (D button) ====================
boolean showUrlPrompt = false;
String urlInput = defaultImageUrl;
int promptW = 740;
int promptH = 180;
PVector promptPos;

// ==================== Processing lifecycle ====================
void settings() { fullScreen(); } // APDE-friendly
void setup() {
  smooth(4);
  originOffset = new PVector(width/2f, height/2f);
  lastMillis = millis();
  // Buttons
  float bx = 16, by = 16, bw = 96, bh = 44, gap = 12;
  btnPOF = new Btn("POF", bx, by, bw, bh, 0);
  btnLOF = new Btn("LOF", bx + bw + gap, by, bw, bh, 1);
  btnST  = new Btn("ST", bx + 2*(bw + gap), by, bw, bh, 2);
  btnD   = new Btn("D",  bx + 3*(bw + gap), by, bw, bh, 3);

  // Ensure data folder exists
  File dataDir = new File(sketchPath("data"));
  if (!dataDir.exists()) dataDir.mkdirs();

  // Try to load default image (local first, then download, then URL)
  attemptLoadOrDownload(imageUrl);
}

void draw() {
  background(255);
  // Time step
  int now = millis();
  int dt = now - lastMillis;
  lastMillis = now;

  // Advance tracer only when tracing and we have a built polyline
  if (mode == MODE_TRACING && points.size() >= 2) {
    float segmentDuration = duration / (float)(points.size() - 1);
    t += dt / segmentDuration;
    if (t >= 1) {
      t = 0;
      currentSegment = (currentSegment + 1) % (points.size() - 1);
    }
  }

  // Compute tracer world position
  PVector tracerWorld;
  if (points.size() >= 2) {
    PVector p0 = points.get(currentSegment);
    PVector p1 = points.get((currentSegment + 1) % points.size());
    tracerWorld = PVector.lerp(p0, p1, t);
  } else {
    tracerWorld = new PVector(0,0);
  }
  PVector tracerScreen = PVector.add(tracerWorld, originOffset);

  // Cartesian grid
  if (showCartesianGrid) drawMovingCartesianGrid(tracerWorld, tracerScreen);

  // Clicked preview (polyline before raster build)
  strokeWeight(2);
  if (!clicked.isEmpty()) {
    stroke(80);
    noFill();
    beginShape();
    for (PVector cw : clicked) vertex(cw.x + originOffset.x, cw.y + originOffset.y);
    endShape();
    if (mode == MODE_POINT_ENTRY) {
      PVector mWorld = screenToWorld(new PVector(mouseX, mouseY));
      mWorld = snapToGrid(mWorld, gridStep);
      stroke(150, 150);
      line(clicked.get(clicked.size()-1).x + originOffset.x, clicked.get(clicked.size()-1).y + originOffset.y,
           mWorld.x + originOffset.x, mWorld.y + originOffset.y);
    }
    noStroke();
    fill(0);
    for (PVector cw : clicked) ellipse(cw.x + originOffset.x, cw.y + originOffset.y, 6, 6);
  }

  // Built rasterized polyline
  if (points.size() >= 2) {
    stroke(0);
    strokeWeight(2);
    noFill();
    beginShape();
    for (PVector w : points) vertex(w.x + originOffset.x, w.y + originOffset.y);
    endShape();
  }

  // Tracer tail + tracer dot
  if (mode == MODE_TRACING && points.size() >= 2) {
    path.add(tracerScreen.copy());
    stroke(0, 150, 255);
    strokeWeight(2);
    noFill();
    beginShape();
    for (PVector s : path) vertex(s.x, s.y);
    endShape();
    noStroke();
    fill(255, 0, 0);
    ellipse(tracerScreen.x, tracerScreen.y, 12, 12);
  }

  // Reference image overlay (draw UNDER buttons so buttons stay clickable)
  if (showRef && refImg != null) {
    pushStyle();
    tint(255, constrain(refAlpha, 0, 255));
    image(refImg, refPos.x, refPos.y, refImg.width * refScale, refImg.height * refScale);
    noFill();
    stroke(0, 80);
    rect(refPos.x, refPos.y, refImg.width * refScale, refImg.height * refScale);
    popStyle();
  }

  // Optional hex overlay info + draw if (showHexGrid)
  if (showHexGrid) {
    Axial tracerAx = pixelScreenToAxial(tracerScreen);
    Cube tracerCube = axialToCube(tracerAx);
    drawFixedHexGridAround(tracerWorld, tracerScreen);
    fill(0);
    textAlign(LEFT, BOTTOM);
    textSize(22);
    text("Hex axial (q,r): (" + tracerAx.q + ", " + tracerAx.r + ") cube (" + tracerCube.q + ", " + tracerCube.r + ", " + tracerCube.s + ")", 20, height - 80);
  }

  // Buttons (draw after overlay so they stay visible)
  btnPOF.draw();
  btnLOF.draw();
  btnST.draw();
  btnD.draw();

  // Readouts
  fill(0);
  textAlign(LEFT, BOTTOM);
  textSize(20);
  String mname = (mode==MODE_POINT_ENTRY?"POINT_ENTRY":mode==MODE_LINES_BUILT?"LINES_BUILT":"TRACING");
  text("Mode: " + mname + " gridStep=" + gridStep, 20, height - 22);
  if (points.size() >= 2) {
    text("Tracer world (x,y): (" + round(tracerWorld.x) + ", " + round(tracerWorld.y) + ")", 20, height - 50);
  }

  // URL prompt overlay (if visible)
  if (showUrlPrompt) drawUrlPrompt();
}

// ==================== Interaction ====================
void mousePressed() {
  // If URL prompt shown, intercept clicks for its buttons
  if (showUrlPrompt) {
    if (mouseX >= promptPos.x + 20 && mouseX <= promptPos.x + promptW - 20 &&
        mouseY >= promptPos.y + 60 && mouseY <= promptPos.y + 100) {
      // clicked inside text field — focus (we already accept keyboard)
      return;
    }
    // Place button
    float pw = 120, ph = 40;
    float px = promptPos.x + promptW - pw - 24;
    float py = promptPos.y + promptH - ph - 18;
    if (mouseX >= px && mouseX <= px + pw && mouseY >= py && mouseY <= py + ph) {
      // Place
      imageUrl = urlInput.trim();
      attemptLoadOrDownload(imageUrl);
      showUrlPrompt = false;
      return;
    }
    // Cancel button
    float cx = promptPos.x + 24, cy = py;
    if (mouseX >= cx && mouseX <= cx + pw && mouseY >= cy && mouseY <= cy + ph) {
      showUrlPrompt = false;
      return;
    }
    // Click outside prompt closes it
    if (!(mouseX >= promptPos.x && mouseX <= promptPos.x + promptW && mouseY >= promptPos.y && mouseY <= promptPos.y + promptH)) {
      showUrlPrompt = false;
      return;
    }
  }

  // Buttons first (priority)
  if (btnPOF.over(mouseX, mouseY)) { btnPOF.click(); return; }
  if (btnLOF.over(mouseX, mouseY)) { btnLOF.click(); return; }
  if (btnST.over(mouseX, mouseY))  { btnST.click();  return; }
  if (btnD.over(mouseX, mouseY))   { btnD.click();   return; }

  // Start dragging reference image if over it
  if (overRef(mouseX, mouseY)) { startDragRef(mouseX, mouseY); return; }

  // Add points only in entry mode
  if (mode == MODE_POINT_ENTRY) {
    PVector w = screenToWorld(new PVector(mouseX, mouseY));
    w = snapToGrid(w, gridStep);
    clicked.add(w);
  }
}
void mouseDragged() {
  if (draggingRef) {
    refPos.x = mouseX - dragOffset.x;
    refPos.y = mouseY - dragOffset.y;
  }
}
void mouseReleased() { endDragRef(); }
void keyPressed() {
  // If URL prompt active, capture text input
  if (showUrlPrompt) {
    if (key == BACKSPACE) {
      if (urlInput.length() > 0) urlInput = urlInput.substring(0, urlInput.length()-1);
    } else if (key == ENTER || key == RETURN) {
      // treat Enter as Place
      imageUrl = urlInput.trim();
      attemptLoadOrDownload(imageUrl);
      showUrlPrompt = false;
    } else if (key >= 32) { // printable
      urlInput += key;
    }
    return; // consume
  }

  // Normal keys
  if (key == 'c' || key == 'C') showCartesianGrid = !showCartesianGrid;
  if (key == 'h' || key == 'H') showHexGrid = !showHexGrid;
  if (key == '+' || key == '=') gridStep = max(4, gridStep + 2);
  if (key == '-' || key == '_') gridStep = max(2, gridStep - 2);
  if (key == 'r' || key == 'R') resetAll();
  // Reference image controls
  if (key == 'i' || key == 'I') showRef = !showRef;
  if (key == '[') refAlpha = max(0, refAlpha - 10);
  if (key == ']') refAlpha = min(255, refAlpha + 10);
  if (key == ',') refScale = max(0.05, refScale - 0.05);
  if (key == '.') refScale = min(5.0, refScale + 0.05);
}

// ====== Button actions ======
void onPOF() {
  if (clicked.size() < 2) return;
  mode = MODE_LINES_BUILT; // lock point entry
}
void onLOF() {
  if (mode == MODE_POINT_ENTRY || clicked.size() < 2) return;
  buildRasterPathFromClicked();
  mode = MODE_LINES_BUILT;
}
void onST() {
  if (points.size() < 2) return;
  currentSegment = 0;
  t = 0;
  path.clear();
  mode = MODE_TRACING;
}
void onD() {
  // show URL prompt (pre-filled)
  urlInput = imageUrl != null ? imageUrl : defaultImageUrl;
  showUrlPrompt = true;
  promptPos = new PVector((width - promptW)/2, (height - promptH)/2);
}
void resetAll(){
  clicked.clear();
  points.clear();
  path.clear();
  mode = MODE_POINT_ENTRY;
  currentSegment = 0;
  t = 0;
}

// ==================== Build raster path from clicked points ====================
void buildRasterPathFromClicked() {
  points.clear();
  for (int i = 0; i < clicked.size(); i++) {
    PVector a = clicked.get(i);
    PVector b = clicked.get((i + 1) % clicked.size()); // closed loop
    ArrayList<PVector> seg = bresenhamGrid(a, b, gridStep);
    if (points.isEmpty()) {
      points.addAll(seg);
    } else {
      for (int k = 0; k < seg.size(); k++) {
        PVector p = seg.get(k);
        if (k == 0) {
          PVector last = points.get(points.size() - 1);
          if (last.x == p.x && last.y == p.y) continue;
        }
        points.add(p);
      }
    }
  }
  // Close loop explicitly
  if (!points.isEmpty()) {
    PVector first = points.get(0);
    PVector last = points.get(points.size() - 1);
    if (first.x != last.x || first.y != last.y) points.add(first.copy());
  }
}

// ==================== Helpers ====================
PVector screenToWorld(PVector s){ return PVector.sub(s, originOffset); }
PVector snapToGrid(PVector w, int step) { float gx = round(w.x / step) * step; float gy = round(w.y / step) * step; return new PVector(gx, gy); }

ArrayList<PVector> bresenhamGrid(PVector aWorld, PVector bWorld, int step) {
  int ax = round(aWorld.x / step);
  int ay = round(aWorld.y / step);
  int bx = round(bWorld.x / step);
  int by = round(bWorld.y / step);
  ArrayList<PVector> out = new ArrayList<PVector>();
  int dx = abs(bx - ax);
  int dy = abs(by - ay);
  int sx = ax < bx ? 1 : -1;
  int sy = ay < by ? 1 : -1;
  int x = ax, y = ay;
  if (dx >= dy) {
    int err = dx / 2;
    for (;;) {
      out.add(new PVector(x * step, y * step));
      if (x == bx && y == by) break;
      x += sx;
      err -= dy;
      if (err < 0) { y += sy; err += dx; }
    }
  } else {
    int err = dy / 2;
    for (;;) {
      out.add(new PVector(x * step, y * step));
      if (x == bx && y == by) break;
      y += sy;
      err -= dx;
      if (err < 0) { x += sx; err += dy; }
    }
  }
  return out;
}

// ==================== Moving cartesian grid (centered on tracer) ====================
void drawMovingCartesianGrid(PVector tracerWorld, PVector tracerScreen) {
  float axisLength = 800;
  float tickSize = 8;
  strokeWeight(1);
  textSize(22);
  fill(0);
  for (float i = -axisLength; i <= axisLength; i += gridStep) {
    float y = tracerScreen.y + i;
    stroke(235); line(0, y, width, y);
    if (abs(i) > 0.0001f) { stroke(0); line(tracerScreen.x - tickSize, y, tracerScreen.x + tickSize, y); }
  }
  for (float i = -axisLength; i <= axisLength; i += gridStep) {
    float x = tracerScreen.x + i;
    stroke(235); line(x, 0, x, height);
    if (abs(i) > 0.0001f) { stroke(0); line(x, tracerScreen.y - tickSize, x, tracerScreen.y + tickSize); }
  }
  stroke(0); strokeWeight(3);
  line(tracerScreen.x - axisLength, tracerScreen.y, tracerScreen.x + axisLength, tracerScreen.y);
  line(tracerScreen.x, tracerScreen.y - axisLength, tracerScreen.x, tracerScreen.y + axisLength);
}

// ==================== (optional) hex overlay helpers ====================
class Axial { int q, r; Axial(int q, int r){ this.q=q; this.r=r; } }
class Cube { int q, r, s; Cube(int q,int r,int s){ this.q=q; this.r=r; this.s=s; } }
class CubeF { float q, r, s; CubeF(float q,float r,float s){ this.q=q; this.r=r; this.s=s; } }

Cube axialToCube(Axial a){ int q=a.q, r=a.r, s=-q-r; return new Cube(q,r,s); }
Axial cubeToAxial(Cube c){ return new Axial(c.q,c.r); }
Cube cubeRound(CubeF c){ int rq = round(c.q), rr = round(c.r), rs = round(c.s); float dq = abs(rq - c.q), dr = abs(rr - c.r), ds = abs(rs - c.s); if (dq > dr && dq > ds) rq = -rr - rs; else if (dr > ds) rr = -rq - rs; else rs = -rq - rr; return new Cube(rq, rr, rs); }

Axial pixelScreenToAxial(PVector screenPx) {
  PVector p = PVector.sub(screenPx, originOffset);
  float qf, rf;
  if (pointyTop) {
    qf = (sqrt(3)/3.0f * p.x - 1.0f/3.0f * p.y) / hexSize;
    rf = (2.0f/3.0f * p.y) / hexSize;
  } else {
    qf = (2.0f/3.0f * p.x) / hexSize;
    rf = (-1.0f/3.0f * p.x + sqrt(3)/3.0f * p.y) / hexSize;
  }
  CubeF cf = new CubeF(qf, rf, -qf - rf);
  return cubeToAxial(cubeRound(cf));
}

PVector[] hexPolygon(float cx, float cy, float size, boolean pointy) {
  PVector[] v = new PVector[6];
  float startAngle = pointy ? PI/6.0f : 0;
  for (int i = 0; i < 6; i++) {
    float ang = startAngle + TWO_PI * i / 6.0f;
    v[i] = new PVector(cx + size * cos(ang), cy + size * sin(ang));
  }
  return v;
}
PVector axialToPixelLocal(Axial a) {
  float x, y;
  if (pointyTop) {
    x = hexSize * (sqrt(3) * (a.q + a.r / 2.0f));
    y = hexSize * (3.0f/2.0f * a.r);
  } else {
    x = hexSize * (3.0f/2.0f * a.q);
    y = hexSize * (sqrt(3) * (a.r + a.q / 2.0f));
  }
  return new PVector(x, y);
}
PVector axialToPixelWorld(Axial a){ return PVector.add(axialToPixelLocal(a), originOffset); }
void drawHexAtWorld(Axial a) {
  PVector p = axialToPixelWorld(a);
  PVector[] pts = hexPolygon(p.x, p.y, hexSize, pointyTop);
  noFill();
  stroke(200);
  strokeWeight(1);
  beginShape();
  for (int i = 0; i < 6; i++) vertex(pts[i].x, pts[i].y);
  endShape(CLOSE);
}
void drawFixedHexGridAround(PVector tracerWorld, PVector tracerScreen) {
  Axial centerAx = pixelScreenToAxial(tracerScreen);
  for (int r = -hexRadiusToDraw; r <= hexRadiusToDraw; r++) {
    int qmin = max(-hexRadiusToDraw, -r - hexRadiusToDraw);
    int qmax = min(hexRadiusToDraw, -r + hexRadiusToDraw);
    for (int q = qmin; q <= qmax; q++) {
      Axial a = new Axial(q + centerAx.q, r + centerAx.r);
      PVector world = axialToPixelWorld(a);
      if (world.x < -hexSize || world.x > width + hexSize || world.y < -hexSize || world.y > height + hexSize) continue;
      drawHexAtWorld(a);
    }
  }
}

// ==================== URL prompt drawing ====================
void drawUrlPrompt() {
  pushStyle();
  fill(0, 120);
  rect(0,0,width,height);
  // prompt box
  fill(255);
  stroke(0);
  rect(promptPos.x, promptPos.y, promptW, promptH, 12);
  fill(0);
  textAlign(LEFT, TOP);
  textSize(18);
  text("Enter image URL to download and place (edit then click Place):", promptPos.x + 18, promptPos.y + 12);
  // text field
  fill(250);
  stroke(0, 100);
  rect(promptPos.x + 20, promptPos.y + 60, promptW - 40, 40, 6);
  fill(0);
  textAlign(LEFT, CENTER);
  textSize(16);
  String display = urlInput;
  // clip display if too long
  if (textWidth(display) > (promptW - 80)) {
    // show trailing portion
    int len = display.length();
    while (len > 0 && textWidth(display.substring(len/2)) > (promptW - 80)) len++;
    // fallback: show last 80 chars approx
    display = display.substring(max(0, display.length()-80));
  }
  text(display, promptPos.x + 28, promptPos.y + 80);

  // Place & Cancel buttons
  float pw = 120, ph = 40;
  float px = promptPos.x + promptW - pw - 24;
  float py = promptPos.y + promptH - ph - 18;
  float cx = promptPos.x + 24, cy = py;
  // Cancel
  fill(240);
  stroke(0);
  rect(cx, cy, pw, ph, 8);
  fill(0); textAlign(CENTER, CENTER); text("Cancel", cx + pw/2, cy + ph/2);
  // Place
  fill(200);
  rect(px, py, pw, ph, 8);
  fill(0); text("Place", px + pw/2, py + ph/2);
  popStyle();
}

// ==================== Utility: download a file from URL to local path (throws) ====================
void downloadFile(String urlString, String outPath) throws Exception {
  URL url = new URL(urlString);
  URLConnection conn = url.openConnection();
  conn.setConnectTimeout(8000);
  conn.setReadTimeout(8000);
  InputStream in = conn.getInputStream();
  FileOutputStream fos = new FileOutputStream(outPath);
  byte[] buffer = new byte[8192];
  int len;
  while ((len = in.read(buffer)) != -1) {
    fos.write(buffer, 0, len);
  }
  fos.close();
  in.close();
}

// ==================== Attempt load/download helper (centers image on success) ====================
void attemptLoadOrDownload(String url) {
  boolean loaded = false;
  // Ensure data folder exists
  File dataDir = new File(sketchPath("data"));
  if (!dataDir.exists()) dataDir.mkdirs();

  // derive filename from url last segment if possible
  String filename = localImageName;
  try {
    String[] parts = url.split("/");
    if (parts.length > 0) {
      String last = parts[parts.length - 1];
      if (last != null && last.length() > 0) {
        filename = last;
      }
    }
  } catch (Exception e) { /* ignore */ }

  String localPath = dataDir.getAbsolutePath() + File.separator + filename;
  File localFile = new File(localPath);

  if (localFile.exists()) {
    println("Found local image at: " + localPath + " — loading from data/");
    refImg = loadImage("data/" + filename);
    if (refImg != null) loaded = true;
  } else {
    println("Local image not found. Attempting to download to: " + localPath);
    try {
      downloadFile(url, localPath);
      println("Download succeeded. Loading local image.");
      refImg = loadImage("data/" + filename);
      if (refImg != null) loaded = true;
    } catch (Exception e) {
      println("Download failed: " + e.getMessage());
    }
  }

  // If still not loaded, try to load directly from URL
  if (!loaded) {
    try {
      println("Attempting to load image directly from URL (may work in desktop mode)...");
      refImg = loadImage(url);
      if (refImg != null) {
        println("Loaded image directly from URL.");
        loaded = true;
      }
    } catch (Exception e) {
      println("Direct URL load failed: " + e.getMessage());
    }
  }

  if (!loaded) {
    println("Warning: reference image not loaded. Place '" + filename + "' inside the sketch 'data' folder manually.");
    refImg = null;
  } else {
    // center it on canvas
    refScale = 1.0; // default scale; user can tweak with , and .
    float w = refImg.width * refScale;
    float h = refImg.height * refScale;
    refPos = new PVector((width - w) / 2.0f, (height - h) / 2.0f);
    showRef = true;
  }
}
