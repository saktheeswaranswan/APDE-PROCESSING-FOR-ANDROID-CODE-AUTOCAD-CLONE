/*
 * Maze Tracer 3D — APDE-safe Cube Edge Tracer (Origin at Cube Corner)
 * Rewritten (GUI in-canvas):
 * - Text boxes for (x,y,z) in meters
 * - ENTER button: add user point
 * - CL button: toggle "connect lines" for user points
 * - TR button: start tracing along user points (order added)
 * - RL (Remove Last), CLR (Clear All)
 * - LOOP toggle: optionally close polyline
 * - Cube AUTO mode preserved; GRID/AXES toggles; zoom buttons; pause/reset
 */

final float PX_PER_M = 100.0f;     // pixels per meter
final float EDGE_M    = 2.0f;      // cube edge length in meters
final float EDGE_PX   = EDGE_M * PX_PER_M; // pixels
final int   TRACE_DURATION_MS = 12000;     // moving time over all edges
final int   DWELL_MS = 500;                // pause 0.5s at each vertex

// Geometry
PVector[] verts;     // 8 cube vertices (world px)
int[] pathOrder;     // edge-walk order over cube vertices (auto mode)
ArrayList<PVector> trail2D = new ArrayList<PVector>(); // HUD trail points (screen px)

// For HUD vertex labels (screen projections each frame)
float[] vScreenX = new float[8];
float[] vScreenY = new float[8];

// Time / tracer
int lastMillis;
float tSeg = 0;      // 0..1 within segment
int segIdx = 0;
boolean paused = false;

// Dwell state
boolean atVertex = false;      // parked on a vertex?
int dwellRemaining = 0;        // ms left to dwell
int lastArrivedVertex = -1;    // index we just reached (for popup)

// Camera/orbit (camera orbits around cube center, NOT at origin corner)
float camYaw   = PI/5.0f;     // left-right orbit angle
float camPitch = -PI/7.0f;    // up-down orbit angle
float camDist  = 6.0f * PX_PER_M; // distance in pixels
int pmx, pmy;
boolean dragging = false;

// Look target = cube center
final PVector lookTarget = new PVector(EDGE_PX/2f, EDGE_PX/2f, EDGE_PX/2f);

// Toggles
boolean showGrid = true;
boolean showAxes = true;

// UI buttons (zoom/pause)
class Btn {
  String label; float x,y,w,h; int id; // id used by the handler
  Btn(String label,float x,float y,float w,float h,int id){this.label=label;this.x=x;this.y=y;this.w=w;this.h=h;this.id=id;}
  void draw(){
    hint(DISABLE_DEPTH_TEST);
    pushStyle(); noStroke();
    fill(255,245); rect(x,y,w,h,10);
    fill(0); textAlign(CENTER,CENTER); textSize(18); text(label, x+w/2, y+h/2);
    popStyle();
    hint(ENABLE_DEPTH_TEST);
  }
  boolean over(float mx,float my){ return mx>=x && mx<=x+w && my>=y && my<=y+h; }
  void click(){
    if (id==0) zoomBy(-0.1f);
    if (id==1) zoomBy(+0.1f);
    if (id==2) paused = !paused;
  }
}
Btn btnPlus, btnMinus, btnPause;

// --- Simple TextBox implementation for user input (meters) ---
class TextBox{
  float x,y,w,h; String text = ""; boolean active=false; String hint = "";
  TextBox(float x,float y,float w,float h,String hint){this.x=x;this.y=y;this.w=w;this.h=h; this.hint=hint;}
  void draw(){
    hint(DISABLE_DEPTH_TEST);
    pushStyle();
    stroke(0); strokeWeight(1);
    if (active) fill(255,255,230); else fill(255,245);
    rect(x,y,w,h,8);
    fill(0); textAlign(LEFT, CENTER); textSize(16);
    String disp = text.length()>0 ? text : hint;
    if (text.length()==0) fill(120);
    text(disp, x+8, y+h/2);
    popStyle();
    hint(ENABLE_DEPTH_TEST);
  }
  boolean over(float mx,float my){ return mx>=x && mx<=x+w && my>=y && my<=y+h; }
  void keyTyped(char k){
    if (!active) return;
    if (k==BACKSPACE){ if (text.length()>0) text = text.substring(0, text.length()-1); }
    else if (k=='\n' || k=='\r') { active = false; }
    else { if ((k>='0' && k<='9') || k=='.' || k=='-' ) text += k; }
  }
}

// User points (in world pixels).
ArrayList<PVector> userPointsPx = new ArrayList<PVector>();

// Buttons for point UI (ENTER, CL, TR, RL, CLR, MODE, LOOP)
Btn btnEnter, btnCL, btnTR, btnRemoveLast, btnClearPoints, btnModeToggle, btnCloseLoop;

// Text boxes for x,y,z (meters)
TextBox tbX, tbY, tbZ;

// Mode: 0 = Auto cube edges, 1 = User points path
int mode = 0;
boolean closeLoop = false;
boolean showUserLines = false; // toggled by CL

void settings() { fullScreen(P3D); }

void setup() {
  smooth(8);
  initCubeCornerOrigin();
  lastMillis = millis();

  float bw=52, bh=36, pad=12;
  btnPlus  = new Btn("+", width - pad - bw, pad, bw, bh, 0);
  btnMinus = new Btn("−", width - pad - bw, pad + bh + 6, bw, bh, 1);
  btnPause = new Btn("⏯", width - pad - bw, pad + 2*(bh + 6), bw, bh, 2);

  // Point UI at top-left
  float ux = 20, uy = 92;
  tbX = new TextBox(ux, uy, 110, 32, "x (m)");
  tbY = new TextBox(ux+120, uy, 110, 32, "y (m)");
  tbZ = new TextBox(ux+240, uy, 110, 32, "z (m)");

  btnEnter       = new Btn("ENTER", ux+360, uy, 90, 32, 10);
  btnCL          = new Btn("CL", ux+454, uy, 52, 32, 11);
  btnTR          = new Btn("TR", ux+510, uy, 52, 32, 12);
  btnRemoveLast  = new Btn("RL", ux+568, uy, 52, 32, 13);
  btnClearPoints = new Btn("CLR", ux+624, uy, 58, 32, 14);

  btnModeToggle  = new Btn("MODE: AUTO", ux+20, uy-44, 140, 32, 15);
  btnCloseLoop   = new Btn("LOOP: OFF", ux+168, uy-44, 120, 32, 16);
}

void draw() {
  // --- time step ---
  int now = millis(); int dt = now - lastMillis; lastMillis = now; if (!paused) advanceTracer(dt);

  // --- 3D viewport ---
  background(255);
  setCamera();

  if (showGrid) drawGroundGridCorner(EDGE_M*2.0f, 0.25f); // ground grid
  if (showAxes) drawAxesFromCorner(EDGE_PX * 1.2f);

  stroke(20); strokeWeight(2); noFill();
  drawCubeEdges();
  drawVertices();

  // User points & connecting polyline (CL toggle)
  drawUserPointsAndLines();

  // Tracer
  PVector tracer = getTracerWorldPx();
  pushMatrix(); translate(tracer.x, tracer.y, tracer.z); noStroke(); fill(255,0,0); sphereDetail(24); sphere(PX_PER_M * 0.08f); popMatrix();

  float sx = screenX(tracer.x, tracer.y, tracer.z); float sy = screenY(tracer.x, tracer.y, tracer.z);
  trail2D.add(new PVector(sx, sy)); if (trail2D.size() > 400) trail2D.remove(0);

  for (int i=0;i<verts.length;i++){ vScreenX[i] = screenX(verts[i].x, verts[i].y, verts[i].z); vScreenY[i] = screenY(verts[i].x, verts[i].y, verts[i].z); }

  drawHUD(tracer, sx, sy);

  // UI buttons
  btnPlus.draw(); btnMinus.draw(); btnPause.draw();
  tbX.draw(); tbY.draw(); tbZ.draw();
  btnEnter.draw(); btnCL.draw(); btnTR.draw(); btnRemoveLast.draw(); btnClearPoints.draw();
  btnModeToggle.draw(); btnCloseLoop.draw();
}

// ============================= Geometry ==============================

void initCubeCornerOrigin() {
  verts = new PVector[8]; float[] s = { 0, EDGE_PX }; int idx = 0;
  for (int zi = 0; zi < 2; zi++) for (int yi = 0; yi < 2; yi++) for (int xi = 0; xi < 2; xi++) verts[idx++] = new PVector(s[xi], s[yi], s[zi]);
  pathOrder = new int[]{ 0,1,3,2,0, 4,5,7,6,4, 5,1,3,7,6,2,0 };
  segIdx = 0; tSeg = 0; trail2D.clear(); atVertex = true; dwellRemaining = DWELL_MS; lastArrivedVertex = pathOrder[0];
}

void drawCubeEdges() {
  int[][] edges = { {0,1},{2,3},{4,5},{6,7}, {0,2},{1,3},{4,6},{5,7}, {0,4},{1,5},{2,6},{3,7} };
  for (int[] e : edges) { PVector a = verts[e[0]], b = verts[e[1]]; line(a.x, a.y, a.z, b.x, b.y, b.z); }
}

void drawVertices() { noStroke(); fill(255,0,0); for (PVector v : verts) { pushMatrix(); translate(v.x, v.y, v.z); sphere(PX_PER_M * 0.06f); popMatrix(); } }

// ============================ User Points & Lines =======================

void drawUserPointsAndLines(){
  // optional connected polyline
  if (userPointsPx.size()>0 && showUserLines){
    stroke(0,100,200); strokeWeight(2); noFill();
    beginShape(); for (PVector p: userPointsPx) vertex(p.x,p.y,p.z); if (closeLoop && userPointsPx.size()>1) vertex(userPointsPx.get(0).x, userPointsPx.get(0).y, userPointsPx.get(0).z); endShape();
  }
  // spheres and labels always
  int idx=0; for (PVector p: userPointsPx){
    pushMatrix(); translate(p.x,p.y,p.z); noStroke(); fill(0,120,200); sphere(PX_PER_M*0.04f); popMatrix();
    float sx = screenX(p.x,p.y,p.z); float sy = screenY(p.x,p.y,p.z);
    if (!Float.isNaN(sx)){
      hint(DISABLE_DEPTH_TEST); pushStyle(); fill(255,235); noStroke(); textSize(14); textAlign(LEFT, CENTER);
      String lbl = idx+": ("+nf(p.x/PX_PER_M,0,2)+", "+nf(p.y/PX_PER_M,0,2)+", "+nf(p.z/PX_PER_M,0,2)+") m";
      float tw = textWidth(lbl); rect(sx+6 -6, sy -10, tw+12, 20, 6); fill(0); text(lbl, sx+12, sy); popStyle(); hint(ENABLE_DEPTH_TEST);
    }
    idx++; }
}

// ============================ Tracer ===============================

void advanceTracer(int dt) {
  if (mode==0){
    advanceTracerForOrder(pathOrder, dt);
  } else {
    if (userPointsPx.size()<1) return;
    int totalPts = userPointsPx.size(); int totalSegs = totalPts - 1 + (closeLoop ? 1 : 0); if (totalSegs<=0) return;
    int[] pOrder = new int[totalPts]; for (int i=0;i<totalPts;i++) pOrder[i]=i;
    advanceTracerForUser(pOrder, dt);
  }
}

void advanceTracerForOrder(int[] order, int dt){
  if (order.length < 2) return; float totalSegs = order.length - 1; float segMs = TRACE_DURATION_MS / totalSegs;
  if (atVertex) { dwellRemaining -= dt; if (dwellRemaining <= 0) { atVertex = false; dwellRemaining = 0; segIdx = (segIdx + 1) % (order.length - 1); tSeg = 0; } return; }
  tSeg += dt / segMs; if (tSeg >= 1.0f) { tSeg = 1.0f; atVertex = true; dwellRemaining = DWELL_MS; int i1 = order[segIdx + 1]; lastArrivedVertex = i1; }
}

void advanceTracerForUser(int[] pOrder, int dt){
  int n = pOrder.length; int totalSegs = n - 1 + (closeLoop ? 1 : 0); if (totalSegs<=0) return; float segMs = TRACE_DURATION_MS / (float)totalSegs;
  if (atVertex) { dwellRemaining -= dt; if (dwellRemaining <= 0) { atVertex = false; dwellRemaining = 0; segIdx = (segIdx + 1) % totalSegs; tSeg = 0; } return; }
  tSeg += dt / segMs; if (tSeg >= 1.0f){ tSeg = 1.0f; atVertex = true; dwellRemaining = DWELL_MS; int arrivedIdx = (segIdx+1 < n) ? pOrder[segIdx+1] : pOrder[0]; lastArrivedVertex = arrivedIdx; }
}

PVector getTracerWorldPx() {
  if (mode==0){
    int i0 = pathOrder[segIdx]; int i1 = pathOrder[segIdx + 1];
    if (atVertex) return verts[lastArrivedVertex >= 0 ? lastArrivedVertex : i0];
    else return PVector.lerp(verts[i0], verts[i1], tSeg);
  } else {
    int n = userPointsPx.size(); if (n==0) return new PVector(0,0,0);
    int totalSegs = n - 1 + (closeLoop ? 1 : 0); if (totalSegs<=0) return userPointsPx.get(0);
    int s = segIdx; int aIdx = s; int bIdx = s+1; if (bIdx >= n) bIdx = 0;
    PVector a = userPointsPx.get(aIdx); PVector b = userPointsPx.get(bIdx);
    if (atVertex) return userPointsPx.get(lastArrivedVertex>=0?lastArrivedVertex:aIdx);
    return PVector.lerp(a,b,tSeg);
  }
}

// ============================ Camera / Orbit ==============================

void setCamera() {
  float cx = lookTarget.x + camDist * cos(camPitch) * cos(camYaw);
  float cy = lookTarget.y + camDist * sin(camPitch);
  float cz = lookTarget.z + camDist * cos(camPitch) * sin(camYaw);
  camera(cx, cy, cz, lookTarget.x, lookTarget.y, lookTarget.z, 0, -1, 0);
  perspective(PI/3.0f, (float)width/height, PX_PER_M*0.02f, PX_PER_M*1000.0f);
}

void zoomBy(float amount) { camDist *= (1.0f + 0.8f * amount); camDist = constrain(camDist, PX_PER_M * 1.2f, PX_PER_M * 40.0f); }

// ============================= HUD & Helpers ==============================

void drawHUD(PVector tracerWorldPx, float tracerSX, float tracerSY) {
  hint(DISABLE_DEPTH_TEST); pushMatrix(); pushStyle(); camera(); ortho(0, width, 0, height, -1, 1);

  noFill(); stroke(0,150,255); strokeWeight(2); beginShape(); for (PVector p : trail2D) vertex(p.x, p.y); endShape();

  fill(0); textAlign(LEFT, BOTTOM); textSize(18);
  String status = paused ? "PAUSED" : (atVertex ? "DWELL (0.5s)" : "RUNNING");
  float xm = tracerWorldPx.x / PX_PER_M, ym = tracerWorldPx.y / PX_PER_M, zm = tracerWorldPx.z / PX_PER_M;
  text("Mode: " + (mode==0?"AUTO (cube)":"USER (points)") + "  Lines:" + (showUserLines?"ON":"OFF") + "  Loop:" + (closeLoop?"ON":"OFF") + "  Status: " + status, 20, height - 22);
  text("Tracer (x,y,z) m: (" + nf(xm,1,2) + ", " + nf(ym,1,2) + ", " + nf(zm,1,2) + ")", 20, height - 46);

  textAlign(LEFT, TOP); text("3D Cube (Origin at Corner) • ENTER points → CL to connect → TR to trace", 20, 18);

  // Cube vertex labels
  textSize(16); textAlign(LEFT, CENTER);
  for (int i=0;i<verts.length;i++){
    float vxm = verts[i].x / PX_PER_M; float vym = verts[i].y / PX_PER_M; float vzm = verts[i].z / PX_PER_M;
    String label = i + ": (" + nf(vxm,0,0) + ", " + nf(vym,0,0) + ", " + nf(vzm,0,0) + ") m";
    float tx = vScreenX[i] + 8, ty = vScreenY[i];
    if (!Float.isNaN(tx) && !Float.isNaN(ty) && tx>=-80 && tx<=width+80 && ty>=-40 && ty<=height+40){
      float padX = 8, padY = 6; float tw = textWidth(label);
      noStroke(); fill(255, 235); rect(tx - padX, ty - (textAscent()*0.6f), tw + 2*padX, textAscent()*0.9f + padY, 8);
      fill(190, 0, 0); text(label, tx, ty);
    }
  }

  // Arrival popup near tracer
  if (atVertex && lastArrivedVertex >= 0 && !Float.isNaN(tracerSX) && !Float.isNaN(tracerSY)) {
    float vxm, vym, vzm;
    if (mode==0){ PVector v = verts[lastArrivedVertex]; vxm=v.x/PX_PER_M; vym=v.y/PX_PER_M; vzm=v.z/PX_PER_M; }
    else { PVector v = userPointsPx.get(lastArrivedVertex); vxm=v.x/PX_PER_M; vym=v.y/PX_PER_M; vzm=v.z/PX_PER_M; }
    String msg = "⦿ " + lastArrivedVertex + ": (" + nf(vxm,0,2) + ", " + nf(vym,0,2) + ", " + nf(vzm,0,2) + ") m";
    float pad = 10; textSize(18); textAlign(LEFT, CENTER); float tw = textWidth(msg); float tx = tracerSX + 14; float ty = tracerSY - 14;
    if (tx + tw + 2*pad > width) tx = width - tw - 2*pad - 10; if (ty - 18 < 0) ty = 24;
    noStroke(); fill(255, 240); rect(tx - pad, ty - 18, tw + 2*pad, 34, 8); fill(0); text(msg, tx, ty);
  }

  popStyle(); popMatrix(); hint(ENABLE_DEPTH_TEST);
}

// Axes from the corner origin (0,0,0) along +X,+Y,+Z
void drawAxesFromCorner(float len) {
  strokeWeight(3); stroke(220,0,0); line(0,0,0,  len,0,0); stroke(0,180,0); line(0,0,0,  0,len,0); stroke(0,0,220); line(0,0,0,  0,0,len);
  drawAxisTip(len,0,0); drawAxisTip(0,len,0); drawAxisTip(0,0,len);
  hint(DISABLE_DEPTH_TEST); pushStyle(); fill(0); textSize(18); textAlign(CENTER, CENTER);
  float sx = screenX(len,0,0), sy = screenY(len,0,0); if (!Float.isNaN(sx)) text("X", sx+12, sy);
  sx = screenX(0,len,0); sy = screenY(0,len,0); if (!Float.isNaN(sx)) text("Y", sx+12, sy);
  sx = screenX(0,0,len); sy = screenY(0,0,len); if (!Float.isNaN(sx)) text("Z", sx+12, sy);
  popStyle(); hint(ENABLE_DEPTH_TEST);
}

void drawAxisTip(float x,float y,float z){ pushMatrix(); translate(x,y,z); noStroke(); fill(0); sphere(PX_PER_M * 0.03f); popMatrix(); }

// Ground grid (XY at z=0)
void drawGroundGridCorner(float sizeM, float stepM) {
  int lines = floor(sizeM / stepM); float sizePx = sizeM * PX_PER_M; float stepPx = stepM * PX_PER_M;
  stroke(230); strokeWeight(1);
  for (int i=0; i<=lines; i++){ float x = i * stepPx; line(x, 0, 0, x, sizePx, 0); }
  for (int j=0; j<=lines; j++){ float y = j * stepPx; line(0, y, 0, sizePx, y, 0); }
  stroke(150); line(0, 0, 0, sizePx, 0, 0); line(0, 0, 0, 0, sizePx, 0);
}

// =============================== Inputs ===================================

void mousePressed() {
  // On-screen UI first
  if (btnPlus.over(mouseX, mouseY)) { btnPlus.click(); return; }
  if (btnMinus.over(mouseX, mouseY)) { btnMinus.click(); return; }
  if (btnPause.over(mouseX, mouseY)) { btnPause.click(); return; }

  if (btnEnter.over(mouseX, mouseY)){ handleEnterPoint(); return; }
  if (btnCL.over(mouseX, mouseY)){ handleCLToggle(); return; }
  if (btnTR.over(mouseX, mouseY)){ handleTRTrace(); return; }
  if (btnRemoveLast.over(mouseX, mouseY)){ if (userPointsPx.size()>0) userPointsPx.remove(userPointsPx.size()-1); return; }
  if (btnClearPoints.over(mouseX, mouseY)){ userPointsPx.clear(); return; }
  if (btnModeToggle.over(mouseX, mouseY)){ handleModeToggle(); return; }
  if (btnCloseLoop.over(mouseX, mouseY)){ closeLoop = !closeLoop; btnCloseLoop.label = "LOOP: " + (closeLoop?"ON":"OFF"); return; }

  // textboxes
  tbX.active = tbX.over(mouseX, mouseY);
  tbY.active = tbY.over(mouseX, mouseY);
  tbZ.active = tbZ.over(mouseX, mouseY);

  // otherwise start camera drag
  dragging = true; pmx = mouseX; pmy = mouseY;
}

void mouseDragged() {
  if (!dragging) return; float dx = mouseX - pmx; float dy = mouseY - pmy; pmx = mouseX; pmy = mouseY;
  camYaw -= dx * 0.006f; camPitch -= dy * 0.006f; camPitch = constrain(camPitch, -PI/2.2f, PI/2.2f);
}

void mouseReleased() { dragging = false; }

void keyTyped() { if (key==CODED) return; tbX.keyTyped(key); tbY.keyTyped(key); tbZ.keyTyped(key); }

void keyPressed() {
  if (key == ' ') paused = !paused;
  if (key == 'r' || key == 'R') resetAll();
  if (key == 'g' || key == 'G') showGrid = !showGrid;
  if (key == 'a' || key == 'A') showAxes = !showAxes;
  if (key == '[')  zoomBy(-0.1f);
  if (key == ']')  zoomBy(+0.1f);
}

// ===================== UI Handlers =====================

void handleEnterPoint(){
  float x = parseFloatOrNaN(tbX.text);
  float y = parseFloatOrNaN(tbY.text);
  float z = parseFloatOrNaN(tbZ.text);
  if (Float.isNaN(x) || Float.isNaN(y) || Float.isNaN(z)) return;
  x = constrain(x, -10, 10); y = constrain(y, -10, 10); z = constrain(z, -10, 10);
  userPointsPx.add(new PVector(x*PX_PER_M, y*PX_PER_M, z*PX_PER_M));
  tbX.text = ""; tbY.text = ""; tbZ.text = "";
}

void handleCLToggle(){ showUserLines = !showUserLines; btnCL.label = showUserLines?"CL✓":"CL"; }

void handleTRTrace(){ if (userPointsPx.size()<1) return; mode = 1; segIdx = 0; tSeg = 0; atVertex = true; dwellRemaining = DWELL_MS; lastArrivedVertex = 0; btnModeToggle.label = "MODE: USER"; }

void handleModeToggle(){ if (mode==0){ mode = 1; btnModeToggle.label = "MODE: USER"; } else { mode = 0; btnModeToggle.label = "MODE: AUTO"; } }

void resetAll(){ segIdx = 0; tSeg = 0; trail2D.clear(); atVertex = true; dwellRemaining = DWELL_MS; lastArrivedVertex = pathOrder[0]; mode = 0; btnModeToggle.label = "MODE: AUTO"; }

// ================== Utilities ==================

float parseFloatOrNaN(String s){ if (s==null || s.length()==0) return Float.NaN; try{ return Float.parseFloat(s); } catch(Exception e){ return Float.NaN; } }

// end of sketch
