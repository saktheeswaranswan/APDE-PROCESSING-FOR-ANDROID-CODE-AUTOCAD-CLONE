/*
 * Maze Tracer 3D — APDE-safe Cube Edge Tracer (Origin at Cube Corner)
 * Rewritten: adds simple on-screen textboxes to input (x,y,z) in meters,
 * - Add Point button: adds a user point (meters -> world px) and plots it
 * - Remove Last / Clear Points
 * - Connect & Trace: build a user path (in order added) and trace along it
 * - Mode toggle: Auto (cube edges) / User (your points)
 * - Close Loop toggle: when tracing user path, optionally close the loop
 * - Shows per-vertex labels (cube + user points), HUD with tracer coords
 * - Shows / hides ground grid and axes; zoom buttons preserved
 *
 * Paste into Processing (APDE / Android) and run in P3D (fullScreen recommended)
 */

final float PX_PER_M = 100.0f;     // pixels per meter
final float EDGE_M    = 2.0f;      // cube edge length in meters
final float EDGE_PX   = EDGE_M * PX_PER_M; // pixels
final int   TRACE_DURATION_MS = 12000;     // moving time over all edges
final int   DWELL_MS = 500;                // pause 0.5s at each vertex

// Geometry
PVector[] verts;     // 8 cube vertices (world px)
int[] pathOrder;     // edge-walk order over cube vertices (auto mode)
ArrayList<PVector> trail2D = new ArrayList<PVector>(); // HUD trail points (screen px)

// For HUD vertex labels (screen projections each frame)
float[] vScreenX = new float[8];
float[] vScreenY = new float[8];

// Time / tracer
int lastMillis;
float tSeg = 0;      // 0..1 within segment
int segIdx = 0;
boolean paused = false;

// Dwell state
boolean atVertex = false;      // parked on a vertex?
int dwellRemaining = 0;        // ms left to dwell
int lastArrivedVertex = -1;    // index we just reached (for popup)

// Camera/orbit (camera orbits around cube center, NOT at origin corner)
float camYaw   = PI/5.0f;     // left-right orbit angle
float camPitch = -PI/7.0f;    // up-down orbit angle
float camDist  = 6.0f * PX_PER_M; // distance in pixels
int pmx, pmy;
boolean dragging = false;

// Look target = cube center
final PVector lookTarget = new PVector(EDGE_PX/2f, EDGE_PX/2f, EDGE_PX/2f);

// Toggles
boolean showGrid = true;
boolean showAxes = true;

// UI buttons (zoom/pause)
class Btn {
  String label; float x,y,w,h; int id; // id used by the handler
  Btn(String label,float x,float y,float w,float h,int id){this.label=label;this.x=x;this.y=y;this.w=w;this.h=h;this.id=id;}
  void draw(){
    hint(DISABLE_DEPTH_TEST);
    pushStyle(); noStroke();
    fill(255,245); rect(x,y,w,h,10);
    fill(0); textAlign(CENTER,CENTER); textSize(22); text(label, x+w/2, y+h/2);
    popStyle();
    hint(ENABLE_DEPTH_TEST);
  }
  boolean over(float mx,float my){ return mx>=x && mx<=x+w && my>=y && my<=y+h; }
  void click(){
    if (id==0) zoomBy(-0.1f);
    if (id==1) zoomBy(+0.1f);
    if (id==2) paused = !paused;
  }
}
Btn btnPlus, btnMinus, btnPause;

// --- Simple TextBox implementation for user input (meters) ---
class TextBox{
  float x,y,w,h; String text = ""; boolean active=false; String hint = "";
  TextBox(float x,float y,float w,float h,String hint){this.x=x;this.y=y;this.w=w;this.h=h; this.hint=hint;}
  void draw(){
    hint(DISABLE_DEPTH_TEST);
    pushStyle();
    stroke(0); strokeWeight(1);
    if (active) fill(255,255,230); else fill(255,245);
    rect(x,y,w,h,8);
    fill(0); textAlign(LEFT, CENTER); textSize(18);
    String disp = text.length()>0 ? text : hint;
    if (text.length()==0) fill(120);
    text(disp, x+8, y+h/2);
    popStyle();
    hint(ENABLE_DEPTH_TEST);
  }
  boolean over(float mx,float my){ return mx>=x && mx<=x+w && my>=y && my<=y+h; }
  void keyTyped(char k){
    if (!active) return;
    if (k==BACKSPACE){ if (text.length()>0) text = text.substring(0, text.length()-1); }
    else if (k=='\n' || k=='\r') { active = false; }
    else {
      // allow only digits, minus, dot
      if ((k>='0' && k<='9') || k=='.' || k=='-' ) text += k;
    }
  }
}

// User points (in world pixels). These are points the user adds via textboxes.
ArrayList<PVector> userPointsPx = new ArrayList<PVector>();

// Buttons for point UI
Btn btnAddPoint, btnRemoveLast, btnClearPoints, btnConnectTrace, btnModeToggle, btnCloseLoop;

// Text boxes for x,y,z (meters)
TextBox tbX, tbY, tbZ;

// Mode: 0 = Auto cube edges, 1 = User points path
int mode = 0;
boolean closeLoop = false;

// Path for user tracing (order is as-added). When tracing, segIdx/tSeg apply to this path.
boolean userTracing = false;

void settings() {
  fullScreen(P3D);
}

void setup() {
  smooth(8);
  initCubeCornerOrigin();
  lastMillis = millis();

  float bw=64, bh=44, pad=14;
  btnPlus  = new Btn("+", width - pad - bw, pad, bw, bh, 0);
  btnMinus = new Btn("−", width - pad - bw, pad + bh + 8, bw, bh, 1);
  btnPause = new Btn("⏯", width - pad - bw, pad + 2*(bh + 8), bw, bh, 2);

  // Point UI at top-left
  float ux = 20, uy = 90;
  tbX = new TextBox(ux, uy, 120, 36, "x (m)");
  tbY = new TextBox(ux+130, uy, 120, 36, "y (m)");
  tbZ = new TextBox(ux+260, uy, 120, 36, "z (m)");

  btnAddPoint = new Btn("Add Point", ux+400, uy, 140, 36, 10);
  btnRemoveLast = new Btn("Remove Last", ux+400, uy+44, 140, 36, 11);
  btnClearPoints = new Btn("Clear Points", ux+400, uy+88, 140, 36, 12);
  btnConnectTrace = new Btn("Connect & Trace", ux+400, uy+132, 140, 40, 13);
  btnModeToggle = new Btn("Mode: AUTO", ux+20, uy-48, 140, 36, 14);
  btnCloseLoop = new Btn("Close Loop: OFF", ux+170, uy-48, 160, 36, 15);
}

void draw() {
  // --- time step ---
  int now = millis();
  int dt = now - lastMillis;
  lastMillis = now;
  if (!paused) advanceTracer(dt);

  // --- 3D viewport ---
  background(255);
  setCamera();

  // Ground grid at z = 0 (from origin corner outward)
  if (showGrid) drawGroundGridCorner(EDGE_M*2.0f, 0.25f);

  // Axes from the corner origin
  if (showAxes) drawAxesFromCorner(EDGE_PX * 1.2f);

  // Cube
  stroke(20); strokeWeight(2); noFill();
  drawCubeEdges();
  drawVertices();

  // Draw user points & connecting polyline
  drawUserPointsAndLines();

  // Tracer sphere + compute screen projection for trail
  PVector tracer = getTracerWorldPx();
  pushMatrix();
  translate(tracer.x, tracer.y, tracer.z);
  noStroke(); fill(255,0,0);
  sphereDetail(24);
  sphere(PX_PER_M * 0.08f); // ~8 cm radius
  popMatrix();

  // --- collect projected 2D point for trail & vertex label projections ---
  float sx = screenX(tracer.x, tracer.y, tracer.z);
  float sy = screenY(tracer.x, tracer.y, tracer.z);
  trail2D.add(new PVector(sx, sy));
  if (trail2D.size() > 400) trail2D.remove(0);

  for (int i=0;i<verts.length;i++){
    vScreenX[i] = screenX(verts[i].x, verts[i].y, verts[i].z);
    vScreenY[i] = screenY(verts[i].x, verts[i].y, verts[i].z);
  }

  // --- HUD (2D overlay) ---
  drawHUD(tracer, sx, sy);

  // UI buttons
  btnPlus.draw();
  btnMinus.draw();
  btnPause.draw();
  // point UI buttons
  tbX.draw(); tbY.draw(); tbZ.draw();
  btnAddPoint.draw(); btnRemoveLast.draw(); btnClearPoints.draw(); btnConnectTrace.draw();
  btnModeToggle.draw(); btnCloseLoop.draw();
}

// ============================= Geometry ==============================

/*
 * Build cube with (0,0,0) at a corner, edges along +X,+Y,+Z.
 * Vertex indices (xyz bits):
 * 0:(0,0,0) 1:(E,0,0) 2:(0,E,0) 3:(E,E,0) 4:(0,0,E) 5:(E,0,E) 6:(0,E,E) 7:(E,E,E)
 */
void initCubeCornerOrigin() {
  verts = new PVector[8];
  float[] s = { 0, EDGE_PX };
  int idx = 0;
  for (int zi = 0; zi < 2; zi++) {
    for (int yi = 0; yi < 2; yi++) {
      for (int xi = 0; xi < 2; xi++) {
        verts[idx++] = new PVector(s[xi], s[yi], s[zi]);
      }
    }
  }
  // Walk all edges in a nice loop touching each face ring + some diagonals along edges
  pathOrder = new int[]{ 0,1,3,2,0, 4,5,7,6,4, 5,1,3,7,6,2,0 };
  segIdx = 0; tSeg = 0; trail2D.clear();
  atVertex = true;                    // start paused at the first vertex
  dwellRemaining = DWELL_MS;
  lastArrivedVertex = pathOrder[0];
}

void drawCubeEdges() {
  int[][] edges = {
    {0,1},{2,3},{4,5},{6,7}, // x-edges
    {0,2},{1,3},{4,6},{5,7}, // y-edges
    {0,4},{1,5},{2,6},{3,7}  // z-edges
  };
  for (int[] e : edges) {
    PVector a = verts[e[0]], b = verts[e[1]];
    line(a.x, a.y, a.z, b.x, b.y, b.z);
  }
}

void drawVertices() {
  noStroke(); fill(255,0,0);
  for (PVector v : verts) {
    pushMatrix();
    translate(v.x, v.y, v.z);
    sphere(PX_PER_M * 0.06f); // ~6 cm
    popMatrix();
  }
}

// ============================ User Points & Lines =======================

void drawUserPointsAndLines(){
  // draw lines connecting user points in order
  if (userPointsPx.size()>0){
    stroke(0,100,200); strokeWeight(2); noFill();
    beginShape();
    for (PVector p: userPointsPx) vertex(p.x,p.y,p.z);
    if (closeLoop && userPointsPx.size()>1) vertex(userPointsPx.get(0).x, userPointsPx.get(0).y, userPointsPx.get(0).z);
    endShape();

    // spheres and labels
    int idx=0;
    for (PVector p: userPointsPx){
      pushMatrix(); translate(p.x,p.y,p.z); noStroke(); fill(0,120,200); sphere(PX_PER_M*0.04f); popMatrix();
      // 2D label
      float sx = screenX(p.x,p.y,p.z); float sy = screenY(p.x,p.y,p.z);
      if (!Float.isNaN(sx)){
        hint(DISABLE_DEPTH_TEST);
        pushStyle(); fill(255,235); noStroke();
        textSize(14); textAlign(LEFT, CENTER);
        String lbl = idx+": ("+nf(p.x/PX_PER_M,0,2)+", "+nf(p.y/PX_PER_M,0,2)+", "+nf(p.z/PX_PER_M,0,2)+") m";
        float tw = textWidth(lbl);
        rect(sx+6 -6, sy -10, tw+12, 20, 6);
        fill(0); text(lbl, sx+12, sy);
        popStyle(); hint(ENABLE_DEPTH_TEST);
      }
      idx++;
    }
  }
}

// ============================ Tracer ===============================

void advanceTracer(int dt) {
  if (mode==0){
    advanceTracerForOrder(pathOrder, dt);
  } else {
    // build index order for user points
    if (userPointsPx.size()<1) return;
    int totalPts = userPointsPx.size();
    int totalSegs = totalPts - 1 + (closeLoop ? 1 : 0);
    if (totalSegs<=0) return;
    // lazy pathOrderUser as 0..n-1
    int[] pOrder = new int[totalPts];
    for (int i=0;i<totalPts;i++) pOrder[i]=i;
    advanceTracerForUser(pOrder, dt);
  }
}

void advanceTracerForOrder(int[] order, int dt){
  if (order.length < 2) return;
  float totalSegs = order.length - 1;
  float segMs = TRACE_DURATION_MS / totalSegs; // moving time per edge

  if (atVertex) {
    dwellRemaining -= dt;
    if (dwellRemaining <= 0) {
      atVertex = false;
      dwellRemaining = 0;
      // begin next edge
      segIdx = (segIdx + 1) % (order.length - 1);
      tSeg = 0;
    }
    return;
  }

  // Moving along an edge
  tSeg += dt / segMs;
  if (tSeg >= 1.0f) {
    // Snap to vertex and dwell
    tSeg = 1.0f;
    atVertex = true;
    dwellRemaining = DWELL_MS;
    int i1 = order[segIdx + 1];
    lastArrivedVertex = i1;
  }
}

void advanceTracerForUser(int[] pOrder, int dt){
  // pOrder are indices 0..n-1; segments = n-1 (+close loop handled in indexing)
  int n = pOrder.length;
  int totalSegs = n - 1 + (closeLoop ? 1 : 0);
  if (totalSegs<=0) return;
  float segMs = TRACE_DURATION_MS / (float)totalSegs;

  if (atVertex) {
    dwellRemaining -= dt;
    if (dwellRemaining <= 0) {
      atVertex = false;
      dwellRemaining = 0;
      segIdx = (segIdx + 1) % totalSegs;
      tSeg = 0;
    }
    return;
  }

  tSeg += dt / segMs;
  if (tSeg >= 1.0f){
    tSeg = 1.0f; atVertex = true; dwellRemaining = DWELL_MS;
    // compute arrived vertex index
    int arrivedIdx;
    if (segIdx+1 < n) arrivedIdx = pOrder[segIdx+1];
    else arrivedIdx = pOrder[0];
    lastArrivedVertex = arrivedIdx; // used only for popup
  }
}

PVector getTracerWorldPx() {
  if (mode==0){
    int i0 = pathOrder[segIdx];
    int i1 = pathOrder[segIdx + 1];
    if (atVertex) {
      return verts[lastArrivedVertex >= 0 ? lastArrivedVertex : i0];
    } else {
      return PVector.lerp(verts[i0], verts[i1], tSeg);
    }
  } else {
    int n = userPointsPx.size();
    if (n==0) return new PVector(0,0,0);
    // build segment endpoints for current segIdx
    int totalSegs = n - 1 + (closeLoop ? 1 : 0);
    if (totalSegs<=0){ return userPointsPx.get(0); }
    int s = segIdx;
    int aIdx = s;
    int bIdx = s+1;
    if (bIdx >= n) bIdx = 0; // wrap if closeLoop
    PVector a = userPointsPx.get(aIdx);
    PVector b = userPointsPx.get(bIdx);
    if (atVertex) return userPointsPx.get(lastArrivedVertex>=0?lastArrivedVertex:aIdx);
    return PVector.lerp(a,b,tSeg);
  }
}

// ============================ Camera / Orbit ==============================

void setCamera() {
  // Spherical orbit around lookTarget → Cartesian camera
  float cx = lookTarget.x + camDist * cos(camPitch) * cos(camYaw);
  float cy = lookTarget.y + camDist * sin(camPitch);
  float cz = lookTarget.z + camDist * cos(camPitch) * sin(camYaw);
  camera(cx, cy, cz, lookTarget.x, lookTarget.y, lookTarget.z, 0, -1, 0);
  perspective(PI/3.0f, (float)width/height, PX_PER_M*0.02f, PX_PER_M*1000.0f);
}

void zoomBy(float amount) {
  camDist *= (1.0f + 0.8f * amount);
  camDist = constrain(camDist, PX_PER_M * 1.2f, PX_PER_M * 40.0f);
}

// ============================= HUD & Helpers ==============================

void drawHUD(PVector tracerWorldPx, float tracerSX, float tracerSY) {
  hint(DISABLE_DEPTH_TEST);
  pushMatrix(); pushStyle();
  camera(); // reset to default 2D
  ortho(0, width, 0, height, -1, 1);

  // Trail
  noFill(); stroke(0,150,255); strokeWeight(2);
  beginShape(); for (PVector p : trail2D) vertex(p.x, p.y); endShape();

  // Text HUD
  fill(0); textAlign(LEFT, BOTTOM); textSize(22);
  String status = paused ? "PAUSED" : (atVertex ? "DWELL (0.5s)" : "RUNNING");
  float xm = tracerWorldPx.x / PX_PER_M;
  float ym = tracerWorldPx.y / PX_PER_M;
  float zm = tracerWorldPx.z / PX_PER_M;
  text("Mode: " + (mode==0?"AUTO (cube edges)":"USER (your points)") + "   Status: " + status, 20, height - 22);
  text("Tracer (x,y,z) m: (" + nf(xm,1,2) + ", " + nf(ym,1,2) + ", " + nf(zm,1,2) + ")", 20, height - 50);

  // Title
  textAlign(LEFT, TOP);
  text("3D Cube (Origin at Corner) • Auto Trace + User Points • Enter points in meters", 20, 20);

  // --- Cube vertex labels ---
  textSize(18); textAlign(LEFT, CENTER);
  for (int i=0;i<verts.length;i++){
    float vxm = verts[i].x / PX_PER_M;
    float vym = verts[i].y / PX_PER_M;
    float vzm = verts[i].z / PX_PER_M;
    String tup = "(" + nf(vxm,0,0) + ", " + nf(vym,0,0) + ", " + nf(vzm,0,0) + ") m";
    String label = i + ": " + tup;
    float tx = vScreenX[i] + 8; float ty = vScreenY[i];
    if (!Float.isNaN(tx) && !Float.isNaN(ty) && tx>=-80 && tx<=width+80 && ty>=-40 && ty<=height+40){
      float padX = 8, padY = 6; float tw = textWidth(label);
      noStroke(); fill(255, 235); rect(tx - padX, ty - (textAscent()*0.6f), tw + 2*padX, textAscent()*0.9f + padY, 8);
      fill(190, 0, 0); text(label, tx, ty);
    }
  }

  // --- Arrival popup while dwelling at a vertex (near tracer) ---
  if (atVertex && lastArrivedVertex >= 0 && !Float.isNaN(tracerSX) && !Float.isNaN(tracerSY)) {
    float vxm, vym, vzm;
    if (mode==0){ PVector v = verts[lastArrivedVertex]; vxm=v.x/PX_PER_M; vym=v.y/PX_PER_M; vzm=v.z/PX_PER_M; }
    else { PVector v = userPointsPx.get(lastArrivedVertex); vxm=v.x/PX_PER_M; vym=v.y/PX_PER_M; vzm=v.z/PX_PER_M; }
    String tup = "(" + nf(vxm,0,2) + ", " + nf(vym,0,2) + ", " + nf(vzm,0,2) + ") m";

    float pad = 10; textSize(20); textAlign(LEFT, CENTER);
    String msg = "⦿ " + lastArrivedVertex + ": " + tup;
    float tw = textWidth(msg); float tx = tracerSX + 14; float ty = tracerSY - 14;
    if (tx + tw + 2*pad > width) tx = width - tw - 2*pad - 10;
    if (ty - 18 < 0) ty = 24;
    noStroke(); fill(255, 240); rect(tx - pad, ty - 18, tw + 2*pad, 34, 8); fill(0); text(msg, tx, ty);
  }

  popStyle(); popMatrix(); hint(ENABLE_DEPTH_TEST);
}

// Axes from the corner origin (0,0,0) along +X,+Y,+Z
void drawAxesFromCorner(float len) {
  strokeWeight(3);
  stroke(220,0,0); line(0,0,0,  len,0,0);
  stroke(0,180,0); line(0,0,0,  0,len,0);
  stroke(0,0,220); line(0,0,0,  0,0,len);
  drawAxisTip(len,0,0); drawAxisTip(0,len,0); drawAxisTip(0,0,len);
  hint(DISABLE_DEPTH_TEST); pushStyle(); fill(0); textSize(20); textAlign(CENTER, CENTER);
  float sx = screenX(len,0,0), sy = screenY(len,0,0); if (!Float.isNaN(sx)) text("X", sx+12, sy);
  sx = screenX(0,len,0); sy = screenY(0,len,0); if (!Float.isNaN(sx)) text("Y", sx+12, sy);
  sx = screenX(0,0,len); sy = screenY(0,0,len); if (!Float.isNaN(sx)) text("Z", sx+12, sy);
  popStyle(); hint(ENABLE_DEPTH_TEST);
}

void drawAxisTip(float x,float y,float z){ pushMatrix(); translate(x,y,z); noStroke(); fill(0); sphere(PX_PER_M * 0.03f); popMatrix(); }

// XY ground grid at z=0, starting at corner (0,0,0) and extending outward
void drawGroundGridCorner(float sizeM, float stepM) {
  int lines = floor(sizeM / stepM);
  float sizePx = sizeM * PX_PER_M;
  float stepPx = stepM * PX_PER_M;
  stroke(230); strokeWeight(1);
  for (int i=0; i<=lines; i++){ float x = i * stepPx; line(x, 0, 0, x, sizePx, 0); }
  for (int j=0; j<=lines; j++){ float y = j * stepPx; line(0, y, 0, sizePx, y, 0); }
  stroke(150); line(0, 0, 0, sizePx, 0, 0); line(0, 0, 0, 0, sizePx, 0);
}

// =============================== Inputs ===================================

void mousePressed() {
  // On-screen UI first
  if (btnPlus.over(mouseX, mouseY)) { btnPlus.click(); return; }
  if (btnMinus.over(mouseX, mouseY)) { btnMinus.click(); return; }
  if (btnPause.over(mouseX, mouseY)) { btnPause.click(); return; }
  if (btnAddPoint.over(mouseX, mouseY)){ handleAddPoint(); return; }
  if (btnRemoveLast.over(mouseX, mouseY)){ handleRemoveLast(); return; }
  if (btnClearPoints.over(mouseX, mouseY)){ handleClearPoints(); return; }
  if (btnConnectTrace.over(mouseX, mouseY)){ handleConnectTrace(); return; }
  if (btnModeToggle.over(mouseX, mouseY)){ handleModeToggle(); return; }
  if (btnCloseLoop.over(mouseX, mouseY)){ handleCloseLoopToggle(); return; }

  // textboxes
  tbX.active = tbX.over(mouseX, mouseY);
  tbY.active = tbY.over(mouseX, mouseY);
  tbZ.active = tbZ.over(mouseX, mouseY);

  // otherwise start camera drag
  dragging = true; pmx = mouseX; pmy = mouseY;
}

void mouseDragged() {
  if (!dragging) return;
  float dx = mouseX - pmx; float dy = mouseY - pmy; pmx = mouseX; pmy = mouseY;
  camYaw   -= dx * 0.006f; camPitch -= dy * 0.006f; camPitch = constrain(camPitch, -PI/2.2f, PI/2.2f);
}

void mouseReleased() { dragging = false; }

void keyTyped() {
  if (key==CODED) return; // ignore arrow keys etc
  tbX.keyTyped(key);
  tbY.keyTyped(key);
  tbZ.keyTyped(key);
}

void keyPressed() {
  if (key == ' ') paused = !paused;
  if (key == 'r' || key == 'R'){
    resetAll();
  }
  if (key == 'g' || key == 'G'){ showGrid = !showGrid; }
  if (key == 'a' || key == 'A'){ showAxes = !showAxes; }
  if (key == '['){ zoomBy(-0.1f); }
  if (key == ']'){ zoomBy(+0.1f); }
}

// ===================== UI Handlers =====================

void handleAddPoint(){
  // parse textboxes as floats in meters
  float x = parseFloatOrNaN(tbX.text);
  float y = parseFloatOrNaN(tbY.text);
  float z = parseFloatOrNaN(tbZ.text);
  if (Float.isNaN(x) || Float.isNaN(y) || Float.isNaN(z)){
    // show small ephemeral status by toggling tb hint (quick hack)
    tbX.text = tbX.text.length()==0?"":tbX.text; // keep current
    return;
  }
  // clamp to cube reasonable range (allow small negative/greater values too)
  x = constrain(x, -10, 10); y = constrain(y, -10, 10); z = constrain(z, -10, 10);
  PVector px = new PVector(x*PX_PER_M, y*PX_PER_M, z*PX_PER_M);
  userPointsPx.add(px);
  // clear inputs
  tbX.text = ""; tbY.text = ""; tbZ.text = "";
}

void handleRemoveLast(){ if (userPointsPx.size()>0) userPointsPx.remove(userPointsPx.size()-1); }
void handleClearPoints(){ userPointsPx.clear(); }

void handleConnectTrace(){
  if (userPointsPx.size()<1) return;
  // start tracing user path
  mode = 1; userTracing = true; segIdx = 0; tSeg = 0; atVertex = true; dwellRemaining = DWELL_MS; lastArrivedVertex = 0; btnModeToggle.label = "Mode: USER";
}

void handleModeToggle(){
  if (mode==0){ mode = 1; btnModeToggle.label = "Mode: USER"; }
  else { mode = 0; btnModeToggle.label = "Mode: AUTO"; }
}

void handleCloseLoopToggle(){ closeLoop = !closeLoop; btnCloseLoop.label = "Close Loop: " + (closeLoop?"ON":"OFF"); }

void resetAll(){
  segIdx = 0; tSeg = 0; trail2D.clear(); atVertex = true; dwellRemaining = DWELL_MS; lastArrivedVertex = pathOrder[0]; mode = 0; btnModeToggle.label = "Mode: AUTO"; }

// ================== Utilities ==================

float parseFloatOrNaN(String s){
  if (s==null || s.length()==0) return Float.NaN;
  try{ return Float.parseFloat(s); } catch(Exception e){ return Float.NaN; }
}

// end of sketch
